/**
 * @file libcomp/tests/GeneratedObjects.cpp
 * @ingroup libcomp
 *
 * @author COMP Omega <compomega@tutanota.com>
 *
 * @brief Test some objects generated by objgen.
 *
 * This file is part of the COMP_hack Library (libcomp).
 *
 * Copyright (C) 2016 COMP_hack Team <compomega@tutanota.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <PushIgnore.h>
#include <gtest/gtest.h>
#include <PopIgnore.h>

#include <TestObject.h>

using namespace libcomp;
using namespace objects;

TEST(Object, TestObject)
{
    TestObject data;

    //
    // Unsigned 8-bit
    //
    EXPECT_EQ(42, data.GetUnsigned8());

    // Attempt to set below the minimum.
    EXPECT_FALSE(data.SetUnsigned8(0));
    EXPECT_EQ(42, data.GetUnsigned8());

    // Attempt to set above the maximum.
    EXPECT_FALSE(data.SetUnsigned8(136));
    EXPECT_EQ(42, data.GetUnsigned8());

    // Attempt to set a valid value.
    EXPECT_TRUE(data.SetUnsigned8(135));
    EXPECT_EQ(135, data.GetUnsigned8());

    //
    // Signed 8-bit
    //
    EXPECT_EQ(0, data.GetSigned8());

    // Attempt to set below the minimum.
    EXPECT_FALSE(data.SetSigned8(-120));
    EXPECT_EQ(0, data.GetSigned8());

    // Attempt to set above the maximum.
    EXPECT_FALSE(data.SetSigned8(125));
    EXPECT_EQ(0, data.GetSigned8());

    // Attempt to set a valid value.
    EXPECT_TRUE(data.SetSigned8(-15));
    EXPECT_EQ(-15, data.GetSigned8());

    //
    // Unsigned 16-bit
    //
    EXPECT_EQ(1337, data.GetUINT16());

    // Attempt to set a valid value.
    EXPECT_TRUE(data.SetUINT16(12345));
    EXPECT_EQ(12345, data.GetUINT16());

    //
    // Signed 32-bit
    //
    EXPECT_EQ(90210, data.GetSigned32());

    //
    // String
    //
    EXPECT_EQ("日本語", data.GetString());

    // Attempt to set a value that is too long.
    EXPECT_FALSE(data.SetString("日本人は大好きです！"));
    EXPECT_EQ("日本語", data.GetString());

    // Attempt to set an invalid value.
    EXPECT_FALSE(data.SetString("日曜日"));
    EXPECT_EQ("日本語", data.GetString());

    // Attempt to set a valid value.
    EXPECT_TRUE(data.SetString("日本人"));
    EXPECT_EQ("日本人", data.GetString());

    //
    // Array
    //
    std::array<float, 3> arrayValues = data.GetXYZ();
    EXPECT_EQ(-1, arrayValues[0]);
    EXPECT_EQ(-1, arrayValues[1]);
    EXPECT_EQ(-1, arrayValues[2]);

    // Try to get a value out of the range.
    EXPECT_EQ(0, data.GetXYZ(10));

    // Try to set some elements with wrong values.
    EXPECT_FALSE(data.SetXYZ(10, 123));
    EXPECT_FALSE(data.SetXYZ(0, -90210));
    EXPECT_FALSE(data.SetXYZ(2, 90210));

    // Try to set some valid values.
    EXPECT_TRUE(data.SetXYZ(0, -0.5f));
    EXPECT_TRUE(data.SetXYZ(1, 1.5f));
    EXPECT_TRUE(data.SetXYZ(2, 3.14159f));

    std::stringstream streamOutStream(std::stringstream::out |
        std::stringstream::binary);
    libcomp::ObjectOutStream streamOut(streamOutStream);

    EXPECT_TRUE(data.Save(streamOut));

    std::string stringData = streamOutStream.str();

    struct
    {
        uint8_t Unsigned8;
        int8_t Signed8;
        uint16_t UINT16;
        int32_t Signed32;
        char string[16];
        float XYZ[3];
    } testData;

    testData.Unsigned8 = 135;
    testData.Signed8 = -15;
    testData.UINT16 = 12345;
    testData.Signed32 = 90210;
    testData.XYZ[0] = -0.5f;
    testData.XYZ[1] = 1.5f;
    testData.XYZ[2] = 3.14159f;

    memset(testData.string, 0, sizeof(testData.string));
    std::vector<char> strA = libcomp::Convert::ToEncoding(
        libcomp::Convert::ENCODING_CP932, "日本人");
    memcpy(testData.string, &strA[0], 15 < strA.size() ? 15 : strA.size());
    //strncpy(testData.string, "日本人", 15);

    EXPECT_EQ(sizeof(testData), stringData.size());
    EXPECT_EQ(0, memcmp(&testData, stringData.c_str(), sizeof(testData)));

    testData.Unsigned8 = 23;
    testData.Signed8 = -77;
    testData.UINT16 = 32814;
    testData.Signed32 = -19842016;

    memset(testData.string, 0, sizeof(testData.string));
    std::vector<char> strB = libcomp::Convert::ToEncoding(
        libcomp::Convert::ENCODING_CP932, "日本一");
    memcpy(testData.string, &strB[0], 15 < strB.size() ? 15 : strB.size());
    //strncpy(testData.string, "日本一", 15);

    std::stringstream streamInStream(std::stringstream::in |
        std::stringstream::binary);
    libcomp::ObjectInStream streamIn(streamInStream);

    streamInStream.str(std::string(reinterpret_cast<char*>(&testData),
        reinterpret_cast<char*>(&testData) + sizeof(testData)));

    EXPECT_TRUE(data.Load(streamIn));

    EXPECT_EQ(23, data.GetUnsigned8());
    EXPECT_EQ(-77, data.GetSigned8());
    EXPECT_EQ(32814, data.GetUINT16());
    EXPECT_EQ(-19842016, data.GetSigned32());
    EXPECT_EQ("日本一", data.GetString());
}

int main(int argc, char *argv[])
{
    try
    {
        ::testing::InitGoogleTest(&argc, argv);

        return RUN_ALL_TESTS();
    }
    catch(...)
    {
        return EXIT_FAILURE;
    }
}
